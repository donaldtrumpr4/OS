#include "iostream"
#include "windows.h"
#include "ctime"
#define THREAD_NUMBER 16
#define COUNT_SIZE 8308330
using namespace std;




struct threads {
    HANDLE thread[THREAD_NUMBER]; //Хендлы потоков
    HANDLE thread_state[THREAD_NUMBER]; //Хендлы ивентов
    bool signaled[THREAD_NUMBER]; //Информация о завершении потоков
};


bool finished(threads a)
{
    bool res = true;
    for (int k = 0;k<THREAD_NUMBER;k++)
        res = res & a.signaled[k];

    return res;
} //Проверяет, завершены ли все потоки

threads appThreads;

struct PI{
    long double PI_COUNT = 0;
    long iter = 0;
}; //Хранит число пи, а также итерацию подсчета

PI var;


//Область параллельного исполнения
DWORD WINAPI counter(CONST LPVOID lpParam) //lpParam в данном случае - индекс потока
{
    long double tmp; //Переменная для подсчета
    long i; //Начало текущего блока
    long cutter; //Конец текущего блока

    while (var.iter<100000000)
    {
        i = var.iter;
        cutter = i + COUNT_SIZE;
        var.iter = cutter;
        if (cutter > 100000000) cutter = 100000000;
        tmp = 0;
        for (long j = i; j < cutter; j++) {
            tmp = tmp + 4 / (100000000 + (j + 0.5) * (j + 0.5) / 100000000);
        }
        var.PI_COUNT = var.PI_COUNT + tmp;
        if (var.iter>=100000000) appThreads.signaled[int(lpParam)] = TRUE; //Если поток получил последний блок итераций, считаем, что он завершен
        SetEvent(appThreads.thread_state[int(lpParam)]);//Установка события, что поток закончил обработку текущего блока итераций
        SuspendThread(GetCurrentThread()); //Приостановка потока
    }
    appThreads.signaled[int(lpParam)] = TRUE;
    SetEvent(appThreads.thread_state[int(lpParam)]);
    ExitThread(0); //Стандартное завершение потока
};


int main()
{

    cout<<"PI counter ver 0.1"<<endl;
    cout<<"Using "<<THREAD_NUMBER<<" threads"<<endl;

    long double time_start,time;
    time_start = clock();
    int index[THREAD_NUMBER];
    for (int k = 0;k<THREAD_NUMBER;k++)
        index[k] = k;


    for (int k = 0;k<THREAD_NUMBER;k++) //Создание потоков и событий
    {
        appThreads.thread[k]=CreateThread(
                nullptr,
                0,
                &counter,
                LPVOID(index[k]),
                CREATE_SUSPENDED,
                nullptr
        );
        appThreads.thread_state[k] = CreateEventA(
                nullptr,
                TRUE,
                TRUE,
                nullptr
                );
        appThreads.signaled[k] = FALSE;
    }


    int T;
    while (!finished(appThreads))
    {
        T = WaitForMultipleObjects(THREAD_NUMBER,appThreads.thread_state,false,INFINITE); //Получает индекс первого отработавшего потока
        Sleep(0);
        ResetEvent(appThreads.thread_state[T]); //Сброс события и продолжение исполнения отработавшего потока
        ResumeThread(appThreads.thread[T]);
    }


    for (int k = 0;k<THREAD_NUMBER;k++) //Закрытие хендлов потоков и событий
    {
        CloseHandle(appThreads.thread[k]);
        CloseHandle(appThreads.thread_state[k]);
    }



    time = (clock() - time_start);
    cout<<"Time taken: "<<time<<" ms"<<endl;
    cout.precision(100000000);

    cout<<"PI = "<<var.PI_COUNT<<endl;




}
